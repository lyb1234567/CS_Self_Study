# 汇编

**通用寄存器**
**AX
BX
CX
DX**
这四个寄存器都是通用寄存器，因为它们都有普通寄存器没有的一个特点，这些通用寄存器都是**16**位寄存器.
同时它们都可以分为两个**8**位寄存器：
AX=AH+AL **AX高8位寄存器构成 AH寄存器  AX低8位寄存器构成AL寄存器**
BX=BH+BL
CX=CH+CL
DX=DH+DL
之所以是8位的原因是因为上一代8086CPU 上一代都是8位寄存器，为了保证兼容，使原来基于CPU编写的程序可以继续使用

![image](https://github.com/lyb1234567/CS_Self_Study/blob/master/Operating%20System/image/%E6%9F%A5%E8%AF%A2%E5%9C%B0%E5%9D%80.PNG?raw=true)
所以一个8086CPU可以处理两种数据：
1. 一字节型数据： 8bits 储存在8位寄存器中（**存储在高位或者低位寄存器中**）
2. 二字节型数据： 16bits 储存在16位寄存器中

**注意：数据与寄存器之间要保持一致**：
比如我们进行操作的时候，如果想将某个数据存入16位寄存器中
```assembly
mov ax,5
```
在DOS中显示就是0005：

![image](https://github.com/lyb1234567/CS_Self_Study/blob/master/Operating%20System/image/%E6%B1%87%E7%BC%96%E6%93%8D%E4%BD%9C.PNG?raw=true)

如果我们进行操作的时候，想将某个数据存入8位寄存器中（比如**AL**）
```assembly
mov al,5
```
在DOS中显示的就是05：

![image](https://github.com/lyb1234567/CS_Self_Study/blob/master/Operating%20System/image/%E4%BD%8E%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8.PNG?raw=true)

**同时需要注意的是：**当进行假发运算时，如果最终结果**大于目标寄存器的位数** 那么，超出的位数会 **直接丢失**
<br/><br/>
**8086 CPU给出物理地址的方法**
8086 CPU有20跟总线，也就是有1MB的寻址能力，但8086CPU又是16位寄存器结构，也就是说，从内部结构来看，它的寻址能力只有64KB（$64*1024=2^{16}$）. 所以为了展现出1MB的寻址能力，8086CPU内部结合两个16位地址，来形成20位的物理地址。
![image](https://github.com/lyb1234567/CS_Self_Study/blob/master/Operating%20System/image/8086CPU.PNG?raw=true)
1. CPU中相关部件提供两个16位地址，一个称为**段地址**，一个称为**偏移地址**
2. 上述两个地址通过内部总线输入到一个称为地址加法器的部件
3. 地址加法器将上述两个地址融合成最终的物理地址
4. 地址加法器通过内部总线将20位物理地址送入输入输出控制电路
5. 输入输出控制电路将20位物理地址送上地址总线
6. 20位物理地址被地址总线传送到储存器
   
**其中：段地址 x 16（其实也就是二进制右移四位，十六进制右移一位） + 偏移地址 = 物理地址**，其本质就是CPU访问内存时，用一个基础地址和一个相对于基础地址的偏移地址相加，给出物理地址。

**CPU读取指令的方法，以及执行过程**
1. 从**CS:IP**中指向的内存单元读取指令，读取的指令进入缓冲器
2. IP=IP+读取指令的长度（比如读取的指令是**B8 20 E9**，那么长度就是三个字节，那么IP执行完就加3）
3. 执行指令，返回步骤1，重复这个过程
从下图中可以看看到，执行完一段指令之后，IP的地址发生了变化。
![image](https://github.com/lyb1234567/CS_Self_Study/blob/master/Operating%20System/image/CPU%E6%89%A7%E8%A1%8C%E6%8C%87%E4%BB%A4%E7%9A%84%E8%BF%87%E7%A8%8B.PNG?raw=true)
<br/><br/>
**关于ds段寄存器**
只有一个偏移地址是没有办法定位一个内存单元的，执行指令时，8086CPU自动取ds中的数据位内存单元的段地址。
如果我们要从地址10000H中读取数据。10000用段地址和偏移地址表示位**1000：0**，那么我们就需要先将1000H放入ds,然后用 mov al,[0]完成传送。

**栈操步骤**
1. 8086CPU提供的栈操作机制，方案如下：
在 **SS,SP**中存放栈顶的段地址和偏移地址，提供入栈和出栈指令指令，它们根据**SS:SP**指示的地址，按照栈的方式访问内存单元

2. **push**指令的执行步骤：1.**SP=SP-2**; 2.向**SS:SP**指向的字单元中传入数据

3. **pop**指令的执行步骤： 1.从**SS:SP**指向的字单元中读取数据 2. **SP=SP+2**

4. 任意时刻，**SS:SP**指向栈顶元素

5. 8086CPU只记录栈顶，栈空间大小需要我们自己管理
6. 用栈来暂时缓存以后需要恢复的寄存器的内容时，寄存器出栈的顺序和入栈的**顺序相反**
7. push,pop实质上是一种内存传送指令

**编译和链接**
1. 编译 masm asm->obj
2. 链接 link obj->exe

具体操作就是在DOSBOX中：先输入**masm xxx**,然后一路**enter**,形成一个**obj**文件，然后使用**link xxx**命令进行链接，形成**exe**文件，最后再在DOSBOX中运行生成的**exe文件：debug xxx.exe**

就是说在执行一段汇编源程序的过程中，操作系统首先会将源程序（xx.asm）中的汇编指令，编译成机器码供操作系统使用，接着形成所需要链接的文件（.obj），然后形成.exe文件。

**mov ax,4c00H,int 21H**
这一段指令的作用是结束一段汇编代码，类似于terminate的作用.

同时，CPU会将加载好的exe文件放入PSP区，这边所谓的PSP区，可以理解位ds寄存去中0~255个字节中的任意区域。
